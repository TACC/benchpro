#!/usr/bin/env python3

# Main executable file for BenchPRO utility
# Performs argument handling, inits glob data structure and starts the appropriate task handler
# Matthew Cawod
# June 2022

# System Imports
import argparse
import os
import sys
import traceback

# MODULE NOT LOADED
def check_module_version():

    sys_dict = { 'frontera' : "/scratch1/hpc_tools/benchpro/modulefiles",
                 'stampede2': "/scratch/hpc_tools/benchpro/modulefiles",
                 'ls6'      : "/scratch/projects/benchtool/modulefiles"
                }

    mismatch = False
    # Not loaded
    if not os.environ.get("BPS_HOME"):
        print("It seems the benchpro module is not loaded.")
        mismatch = True

    mod_version = os.environ.get('BPS_VERSION')
    required_version = "1.7.3"
    # Version mismatch
    if mod_version != required_version:
        print("Version mismatch: yours=" + mod_version + ", site=" + required_version)
        mismatch = True
        
    if mismatch:
        print("Reload the module with:")
        print("Development site:")
        print("ml use /scratch1/08780/benchpro/benchpro-dev/modulefiles")
        print()
        print("Production site:")
        print("ml use " + sys_dict[os.environ.get('TACC_SYSTEM')])
        print()
        print("ml benchpro")
        print()
        print("HINT: You can load BenchPRO automatically next time by adding it to your default module collection:")
        print("ml save")
        sys.exit(1)

check_module_version()

# Synchronize the user's benchpro repo with this site version
#import src.sync_handler     as sync
#sync.resync()

# Local Imports
try:
    import src.bench_manager    as bench_manager
    import src.build_manager    as build_manager
    import src.global_settings  as global_settings
    import src.notices          as notices
    import src.result_manager   as result_manager
    import src.splash           as splash
    import src.validator        as validator

# Catch import exception
except ImportError as e:
    print("Python import error!")
    print(traceback.format_exc())
    print(e)
    sys.exit(1)

# Catch exception in a handler, write to log and quit
def catch_major_exception(glob, e):


    if not glob:
        print("Failed to create glob object")
        print(traceback.format_exc())
        print(e)
        sys.exit(1)

    if not glob.stg['debug']:

        print("It appears something has gone wrong!")
        print(e)

        if glob.log:
            glob.log.debug(traceback.format_exc())
            print("Traceback written to log.")
        else:
            print(traceback.format_exc())
        sys.exit(1)

    else: 
        print(traceback.format_exc())
        print(e)
        sys.exit(1)

# Get cmdline arguments
def get_arguments():


    # Parse cmdline args
    cmd_parser = argparse.ArgumentParser(
        description='This is a benchmarking tool to automate the installation of applications, \
                    execution of benchmarks and collection of results.')

    cmd_parser.add_argument(
        "--force",
        default=False,
        action='store_true',
        help="Forcibly delete multiple applications/benchmarks meeting your selection criteria.")

    cmd_parser.add_argument(
        "--notices",
        default=False,
        action='store_true',
        help="Print notices and quit.")

    cmd_parser.add_argument(
        "--env",
        default=False,
        action='store_true',
        help="Print environment variables and quit.")

    cmd_parser.add_argument(
        "--settings",
        default=False,
        help="Provide .ini file with nonstandard install paths.")

    cmd_parser.add_argument(
        "-b",
        "--build",
        default=False,
        nargs='+',
        type=str,
        help="Name of the code config file to build, run --avail to check. Accepts list.")

    cmd_parser.add_argument(
        "--sched",
        default=False,
        type=str,
        help="Name of the scheduler config file, will use system default otherwise.")

    cmd_parser.add_argument(
        "-B",
        "--bench",
        default=False,
        nargs='+',
        type=str,
        help="Name of benchmark config file to bench, run --avail to check. Accepts list.")

    cmd_parser.add_argument(
        "-C",
        "--capture",
        default=False,
        action='store_true',
        help="Send results to database.")

    cmd_parser.add_argument(
        "-lr",
        "--listResults",
        nargs='?',
        const="all",
        type=str,
        help="Provide summary of benchmarks results. Default is 'all', also takes 'complete', 'complete', 'captured' or \
                                    'failed'")

    cmd_parser.add_argument(
        "-dr",
        "--delResult",
        default=False,
        nargs='+',
        help="Deletes benchmark result from local directory, takes benchmark label, 'captured', 'failed' or 'all'")

    cmd_parser.add_argument(
        "-c",
        "--clean",
        default=False,
        action='store_true',
        help="Cleanup temp and log files.")

    cmd_parser.add_argument(
        "-la",
        "--listApps",
        default=False,
        action='store_true',
        help="Show all installed applications.")

    cmd_parser.add_argument(
        "-a",
        "--avail",
        nargs='?',
        const="all",
        type=str,
        help="Show all available application profiles. Default is 'all', also accepts 'code', 'bench' or 'suite'.")

    cmd_parser.add_argument(
        "-d",
        "--defaults",
        default=False,
        action='store_true',
        help="Print default options for current system.")

    cmd_parser.add_argument(
        "-da",
        "--delApp",
        default=False,
        nargs='+',
        help="Remove an installed application. Accepts list.")

    cmd_parser.add_argument(
        "-qa",
        "--queryApp",
        default=False,
        help="Query build report of an installed application.")

    cmd_parser.add_argument(
        "-qr",
        "--queryResult",
        default=False,
        help="Query a local benchmark result for config info.")

    cmd_parser.add_argument(
        "--dbResult",
        nargs='?',
        const="all",
        type=str,
        help="Query database for benchmark results. Default is 'all'. Accepts comma delimited list \
                                    of key-value pairs as search criteria (username=mcawood,system=frontera).")

    cmd_parser.add_argument(
        "--dbApp",
        default=False,
        type=str,
        help="Provide application ID to print info report from database.")

    cmd_parser.add_argument(
        "--export",
        default=False,
        action='store_true',
        help="Export database query to .csv file dbquery_[date].csv")

    cmd_parser.add_argument("--history", default=False, action='store_true',
                            help="Print benchpro input history.")

    cmd_parser.add_argument("-L", "--last", nargs='?', const=1, type=int,
                            help="Print query from last build or bench task.")

    cmd_parser.add_argument(
        "-o",
        "--overload",
        default=False,
        nargs='+',
        help="Override any setting read from cfg files. OVERLOAD is a list of key-value pairs of the form key=value")


    cmd_parser.add_argument(
        "--purge",
        default=False,
        action='store_true',
        help="Delete all local user files, forever(!). Do not use this unless you know what you are doing.")

    cmd_parser.add_argument(
        "-V",
        "--validate",
        default=False,
        action='store_true',
        help="Run installation validator.")

    cmd_parser.add_argument(
        "-v",
        "--version",
        default=False,
        action='store_true',
        help="Print version info.")

    return cmd_parser.parse_args()

#  
def init_glob():
    # Init global object
    glob = global_settings.setup(get_arguments())
    return glob

def main():

    glob = None
    args = get_arguments()

    if args.notices:
        notices.print_notices(False, True)

    # No input = print notice
    no_input = True
    for key in args.__dict__:
        if args.__dict__[key]:
            no_input = False
    if no_input:    
        notices.info()

    # Set default for sched input
    args.sched = "system"
    
    # Create glob obj
    try:
        glob = init_glob()
    except Exception as e:
        catch_major_exception(glob, e)

    # Add args to glob
    glob.args = args

    # Run validator checker, with --validate as 2nd arg. Forces if True
    validator.check(glob, glob.args.validate) 

    # Start build manager
    if glob.args.build:
        try:
            build_manager.init(glob)
        except Exception as e:
            catch_major_exception(glob, e)

    # Start bench manager
    elif glob.args.bench:
        try:
            bench_manager.init(glob)
        except Exception as e:
            catch_major_exception(glob, e)

    # Start result manager
    elif glob.args.capture:
        try:
            result_manager.capture_result(glob)
        except Exception as e:
            catch_major_exception(glob, e)

    # Cleanup and exit
    elif glob.args.clean:
        glob.lib.misc.clean_temp_files()
    # Show installed and exit
    elif glob.args.listApps:
        glob.lib.misc.show_installed()
    # Print defaults settings
    elif glob.args.defaults:
        glob.lib.misc.print_defaults()
    # Print BP_ and BPS_ EVs
    elif glob.args.env:
        glob.lib.misc.print_env()
    # Show available and exit
    elif glob.args.avail:
        glob.lib.misc.show_available()
    # Remove installation and exit
    elif glob.args.delApp:
        glob.lib.misc.remove_app(None)
    # Query installation and exit
    elif glob.args.queryApp:
        glob.lib.misc.query_app(glob.args.queryApp)
    # Print cmd line history
    elif glob.args.history:
        glob.lib.misc.print_history()
    # Query db for results
    elif glob.args.dbResult:
        result_manager.query_db(glob)
    # Query db for application
    elif glob.args.dbApp:
        result_manager.print_app_from_table(glob)
    # Show results and exit
    elif glob.args.listResults:
        result_manager.list_results(glob)
    # Query result and exit
    elif glob.args.queryResult:
        result_manager.query_result(glob, glob.args.queryResult)
    # Remove result and exit
    elif glob.args.delResult:
        result_manager.remove_result(glob)
    # Purge user files 
    elif glob.args.purge:
        #glob.lib.files.purge()
        print("Purge disabled for now...")
        sys.exit(0)
    elif glob.args.version:
        glob.lib.misc.print_version()
    elif glob.args.last:
        glob.lib.misc.print_last()

    #Print notices
    elif glob.args.notices:
        notices.print_notices(False, True)

    elif not glob.args.validate:
        notices.print_notices(False, False)

    # Need to hit this one day...
    return 0

if __name__ == "__main__":
    sys.exit(main())
